@page "/capteurs"
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize(Roles = "User")]
@using StationMeteoBlazor.Data
@using StationMeteoBlazor.Models
@using System.Security.Claims
@using Microsoft.AspNetCore.Components.Authorization
@inject DonneeCapteurService Service
@inject IJSRuntime JS
@inject NavigationManager Navigation
@inject AuthenticationStateProvider AuthStateProvider
@rendermode InteractiveServer
@attribute [StreamRendering]

<PageTitle>Dashboard Station Météo</PageTitle>
@*Ajout d'un commentaire dernier commit*@
@* Affichage d'un loader central tant que les données sont en cours de chargement *@
@if (isLoading)
{
    <div class="d-flex justify-content-center align-items-center" style="height:240px;">
        <div class="loader" role="status" aria-label="Chargement des données"></div>
    </div>
}
else
{
    <div class="container mt-3 fade-in">

        @* Entête : titre + actions principales alignées à droite *@
        <div class="d-flex justify-content-between align-items-center mb-3">
            <h3 class="mb-0">Station météo — Dashboard</h3>
            <div class="d-flex align-items-center">
                <small class="text-muted me-3">Dernière mise à jour : @LastUpdateString</small>
                <button class="btn btn-secondary me-2" @onclick="ActualiserDonnees">🔄 Actualiser</button>
                <button class="btn btn-primary" @onclick="ExporterPDF">📄 Exporter</button>
            </div>
        </div>

        @* Sélecteur de période *@
        <div class="mb-4">
            <label class="form-label me-2">Période :</label>
            <select class="form-select w-auto d-inline-block" @onchange="ChangerPlageDonnees" aria-label="Sélecteur période">
                <option value="1">Dernière heure</option>
               @* <option value="168">7 jours</option>*@
                <option value="0">Toutes les données</option>
            </select>
        </div>

        @if (!capteurs.Any())
        {
            <div class="alert alert-info">Aucune donnée de capteur trouvée pour votre compte.</div>
        }
        else
        {
            @* Cartes métriques : température / humidité / pression / vent *@
            <div class="row g-3 mb-4">
                <div class="col-sm-6 col-md-3">
                    <div class="card shadow-sm text-center p-3 h-100">
                        <div class="card-body">
                            <h6 class="card-title text-muted">Température</h6>
                            <h2 class="display-6">@dernierTemp °C</h2>
                            <small class="text-muted">Dernier relevé</small>
                        </div>
                    </div>
                </div>

                <div class="col-sm-6 col-md-3">
                    <div class="card shadow-sm text-center p-3 h-100">
                        <div class="card-body">
                            <h6 class="card-title text-muted">Humidité</h6>
                            <h2 class="display-6">@dernierHum %</h2>
                            <small class="text-muted">Dernier relevé</small>
                        </div>
                    </div>
                </div>

                <div class="col-sm-6 col-md-3">
                    <div class="card shadow-sm text-center p-3 h-100">
                        <div class="card-body">
                            <h6 class="card-title text-muted">Pression</h6>
                            <h2 class="display-6">@dernierPress hPa</h2>
                            <small class="text-muted">Dernier relevé</small>
                        </div>
                    </div>
                </div>

                <div class="col-sm-6 col-md-3">
                    <div class="card shadow-sm text-center p-3 h-100">
                        <div class="card-body">
                            <h6 class="card-title text-muted">Vent</h6>
                            <h2 class="display-6">@dernierVent m/s</h2>
                            <small class="text-muted">Dernier relevé</small>
                        </div>
                    </div>
                </div>
            </div>

            @* Graphiques : un grand combiné, puis grille de graphiques secondaires *@
            <div class="card shadow-sm p-4 mb-4">
                <h5 class="mb-3">Température — Humidité</h5>
                <div class="ratio ratio-16x6">
                    <canvas id="graphCombine" aria-label="Graphique température et humidité"></canvas>
                </div>
            </div>

            <div class="row">
                <div class="col-lg-6 mb-4">
                    <div class="card shadow-sm p-3 h-100">
                        <h6>Température</h6>
                        <div class="ratio ratio-16x9">
                            <canvas id="graphTemp"></canvas>
                        </div>
                    </div>
                </div>

                <div class="col-lg-6 mb-4">
                    <div class="card shadow-sm p-3 h-100">
                        <h6>Humidité</h6>
                        <div class="ratio ratio-16x9">
                            <canvas id="graphHum"></canvas>
                        </div>
                    </div>
                </div>

                <div class="col-lg-6 mb-4">
                    <div class="card shadow-sm p-3 h-100">
                        <h6>Pression</h6>
                        <div class="ratio ratio-16x9">
                            <canvas id="graphPression"></canvas>
                        </div>
                    </div>
                </div>

                <div class="col-lg-6 mb-4">
                    <div class="card shadow-sm p-3 h-100">
                        <h6>Lumière</h6>
                        <div class="ratio ratio-16x9">
                            <canvas id="graphLum"></canvas>
                        </div>
                    </div>
                </div>

                <div class="col-lg-6 mb-4">
                    <div class="card shadow-sm p-3 h-100">
                        <h6>Pluie</h6>
                        <div class="ratio ratio-16x9">
                            <canvas id="graphPluie"></canvas>
                        </div>
                    </div>
                </div>

                <div class="col-lg-6 mb-4">
                    <div class="card shadow-sm p-3 h-100">
                        <h6>Vent (m/s)</h6>
                        <div class="ratio ratio-16x9">
                            <canvas id="graphVent"></canvas>
                        </div>
                    </div>
                </div>

                @* Radar réduit : ratio plus petit pour éviter qu'il domine la page *@
                <div class="col-12 col-lg-6 mb-4">
                    <div class="card shadow-sm p-3 h-100">
                        <h6>Direction du Vent (Radar)</h6>
                        <div class="ratio ratio-4x3" style="max-height:320px; overflow:hidden;">
                            <canvas id="graphRadar"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        }
    </div>
}

@code {
    // identifiant de l'utilisateur connecté
    private int currentUserId;

    // indicateur de chargement
    private bool isLoading = true;

    // message d'erreur non bloquant affiché dans l'UI
    private string? errorMessage;

    // données brutes venant du service (capteurs de l'utilisateur connecté)
    private List<DonneeCapteur> capteurs = new();

    // Séries destinées aux graphiques
    private List<string> labels = new();
    private List<double> temp = new();
    private List<double> hum = new();
    private List<double> press = new();
    private List<double?> lumiere = new();
    private List<double?> pluie = new();
    private List<double?> ventVitesse = new();
    private List<double?> ventDirection = new();

    // Cards métriques (valeurs du dernier relevé)
    private double dernierTemp;
    private double dernierHum;
    private double dernierPress;
    private double dernierVent;

    // date du dernier relevé affichée en entête
    private DateTime? lastUpdate;
    private string LastUpdateString => lastUpdate?.ToString("g") ?? "—";

    protected override async Task OnInitializedAsync()
    {
        isLoading = true;
        StateHasChanged();

        try
        {
            // Récupérer l'utilisateur connecté via AuthenticationStateProvider
            var authState = await AuthStateProvider.GetAuthenticationStateAsync();
            var user = authState?.User;

            // Si non authentifié, rediriger vers la page de login
            if (user == null || !(user.Identity?.IsAuthenticated ?? false))
            {
                Navigation.NavigateTo("/login");
                return;
            }

            // Récupérer l'Id utilisateur depuis la claim NameIdentifier
            var idClaimValue = user.FindFirst(ClaimTypes.NameIdentifier)?.Value;
            if (!int.TryParse(idClaimValue, out currentUserId))
            {
                Navigation.NavigateTo("/login");
                return;
            }

            await Task.Delay(500);
            // Charger uniquement les données du capteur pour l'utilisateur connecté
            capteurs = (await Service.GetAllAsync(currentUserId)) ?? new List<DonneeCapteur>();
            // S'assurer que les données sont triées (récent -> premier)
            capteurs = capteurs.OrderByDescending(c => c.DateMesure).ToList();

            MapperDonnees();
        }
        catch (Exception ex)
        {
            // en prod, logguer plutôt que afficher ; ici fallback simple
            capteurs = new List<DonneeCapteur>();
            Console.Error.WriteLine(ex);
            errorMessage = "Erreur lors du chargement des données.";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    // Conversion des DonneeCapteur en séries Chart.js (defensive null/empty handling)
    private void MapperDonnees()
    {
        if (capteurs == null || !capteurs.Any())
        {
            labels = new List<string>();
            temp = new List<double>();
            hum = new List<double>();
            press = new List<double>();
            lumiere = new List<double?>();
            pluie = new List<double?>();
            ventVitesse = new List<double?>();
            ventDirection = new List<double?>();
            dernierTemp = dernierHum = dernierPress = dernierVent = 0;
            lastUpdate = null;
            return;
        }

        labels = capteurs.Select(c => c.DateMesure.ToString("HH:mm")).ToList();
        temp = capteurs.Select(c => (double)c.Temperature).ToList();
        hum = capteurs.Select(c => (double)c.Humidite).ToList();
        press = capteurs.Select(c => (double)c.Pression).ToList();

        lumiere = capteurs.Select(c => c.Lumiere.HasValue ? (double?)c.Lumiere.Value : null).ToList();
        pluie = capteurs.Select(c => c.Pluie.HasValue ? (double?)c.Pluie.Value : null).ToList();
        ventVitesse = capteurs.Select(c => c.VentVitesse.HasValue ? (double?)c.VentVitesse.Value : null).ToList();
        ventDirection = capteurs.Select(c => c.VentDirection.HasValue ? (double?)c.VentDirection.Value : null).ToList();

        var last = capteurs.FirstOrDefault();
        if (last != null)
        {
            dernierTemp = (double)last.Temperature;
            dernierHum = (double)last.Humidite;
            dernierPress = (double)last.Pression;
            dernierVent = last.VentVitesse.HasValue ? (double)last.VentVitesse.Value : 0;
            lastUpdate = last.DateMesure;
        }
    }

    // Après le rendu initial, initialiser le thème et dessiner les graphiques via JS interop
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (!firstRender) return;

        // délai augmenté pour laisser le DOM et Chart.js se stabiliser
        await Task.Delay(500);
        await JS.InvokeVoidAsync("initTheme");
        await RenderGraphsAsync();
    }

    // Appels JS pour rendre les graphiques (Chart.js)
    private async Task RenderGraphsAsync()
    {
        // petit délai supplémentaire avant appels JS pour réduire les erreurs côté navigateur
        await Task.Delay(300);

        // Passer des listes même vides — Chart.js gère cela.
        await JS.InvokeVoidAsync("creerGraphiqueCombine", "graphCombine", labels, temp, hum);
        await JS.InvokeVoidAsync("creerGraphique", "graphTemp", labels, temp, "Température");
        await JS.InvokeVoidAsync("creerGraphique", "graphHum", labels, hum, "Humidité");
        await JS.InvokeVoidAsync("creerGraphique", "graphPression", labels, press, "Pression");
        await JS.InvokeVoidAsync("creerGraphique", "graphLum", labels, lumiere, "Lumière");
        await JS.InvokeVoidAsync("creerGraphique", "graphPluie", labels, pluie, "Pluie");
        await JS.InvokeVoidAsync("creerGraphique", "graphVent", labels, ventVitesse, "Vent");
        await JS.InvokeVoidAsync("creerGraphiqueRadar", "graphRadar", labels, ventDirection);
    }

    // Basculer le thème sombre via JS
    private async Task ToggleDarkMode()
    {
        // petit délai pour éviter surcharge d'appels JS successifs
        await Task.Delay(200);
        await JS.InvokeVoidAsync("toggleDarkMode");
    }

    // Changer la période des données (filtrage côté client après récupération)
    private async Task ChangerPlageDonnees(ChangeEventArgs e)
    {
        isLoading = true;
        StateHasChanged();

        try
        {
            // Sécuriser le parse du select
            var s = e?.Value?.ToString();
            if (!int.TryParse(s, out var heures)) heures = 0;

            var all = (await Service.GetAllAsync(currentUserId)) ?? new List<DonneeCapteur>();

            if (heures > 0)
            {
                DateTime limite = DateTime.Now.AddHours(-heures);
                capteurs = all.Where(c => c.DateMesure >= limite).OrderByDescending(c => c.DateMesure).ToList();
            }
            else
            {
                capteurs = all.OrderByDescending(c => c.DateMesure).ToList();
            }

            MapperDonnees();

            // délai pour stabiliser avant redessin des graphiques
            await Task.Delay(400);
            await RenderGraphsAsync();
        }
        catch (Exception ex)
        {
            errorMessage = "Erreur lors du filtrage des données.";
            Console.Error.WriteLine(ex);
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    // Rafraîchir les données depuis le service
    private async Task ActualiserDonnees()
    {
        isLoading = true;
        StateHasChanged();

        try
        {
            capteurs = (await Service.GetAllAsync(currentUserId)) ?? new List<DonneeCapteur>();
            capteurs = capteurs.OrderByDescending(c => c.DateMesure).ToList();
            MapperDonnees();

            // délai volontaire pour réduire probabilité d'erreur côté JS / navigateur
            await Task.Delay(400);
            await RenderGraphsAsync();
        }
        catch (Exception ex)
        {
            errorMessage = "Erreur lors de l'actualisation des données.";
            Console.Error.WriteLine(ex);
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    // Exporter en PDF via JS (fait appel à exportPDF dans graphique.js)
    private async Task ExporterPDF()
    {
        try
        {
            await Task.Delay(300);
            await JS.InvokeVoidAsync("exportPDF");
        }
        catch
        {
            errorMessage = "Export PDF non disponible côté client.";
            StateHasChanged();
        }
    }

    private void OuvrirTicket(int id)
    {
        Navigation.NavigateTo($"/ticket/{id}?from=capteurs");
    }

    private async Task Retry()
    {
        errorMessage = null;
        await OnInitializedAsync();
    }
}
